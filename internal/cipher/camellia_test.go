package cipher

import (
	"bytes"
	"testing"
)

// Test vectors from http://tools.ietf.org/html/rfc3713
var camelliaTests = []struct {
	key    []byte
	plain  []byte
	cipher []byte
}{
	{
		[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},
		[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},
		[]byte{0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73, 0x08, 0x57, 0x06, 0x56, 0x48, 0xea, 0xbe, 0x43},
	},

	// 192-bit key
	{
		[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77},
		[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},
		[]byte{0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8, 0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09, 0xb9},
	},

	//256-bit key
	{
		[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff},
		[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},
		[]byte{0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c, 0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75, 0x09},
	},
}

func TestCamelliaCipher(t *testing.T) {

	for _, tt := range camelliaTests {
		c, _ := NewCamelliaCipher(tt.key)
		var b [16]byte
		c.Encrypt(b[:], tt.plain)
		if !bytes.Equal(b[:], tt.cipher) {
			t.Errorf("encrypt failed:\ngot : % 02x\nwant: % 02x", b, tt.cipher)
		}

		c.Decrypt(b[:], tt.cipher)
		if !bytes.Equal(b[:], tt.plain) {
			t.Errorf("decrypt failed:\ngot : % 02x\nwant: % 02x", b, tt.plain)
		}
	}
}

func encrpp(c Cipher, str string) []byte {
	data := []byte(str)

	// Allocate data for encrypting it
	encrypted_data := make([]byte, len(data)+(c.BlockSize()-len(data)%c.BlockSize())%c.BlockSize())

	// Encrypt the data before sending it
	for i := 0; i < len(encrypted_data)/c.BlockSize(); i++ {
		lower := i * c.BlockSize()
		upper := (i + 1) * c.BlockSize()
		c.Encrypt(encrypted_data[lower:upper], data[lower:upper])
	}
	return encrypted_data
}

func deccrp(c Cipher, data []byte) []byte {

	decrypted_data := make([]byte, len(data)+(c.BlockSize()-len(data)%c.BlockSize())%c.BlockSize())
	// Decrypt data in blocks
	for i := 0; i < len(decrypted_data)/c.BlockSize(); i++ {
		lower := i * c.BlockSize()
		upper := (i + 1) * c.BlockSize()
		c.Decrypt(decrypted_data[lower:upper], data[lower:upper])
	}
	// Remove remaining bytes
	for i := len(decrypted_data) - 1; i > 0 && decrypted_data[i] == byte(0); i-- {
		decrypted_data = decrypted_data[:i]
	}

	return decrypted_data
}

func TestCustomWriter(t *testing.T) {
	data := "Hello! World12341251123(◕‿◕)!_3123"
	c, _ := NewCamelliaCipher(([]byte)("1111111111111111"))
	encrypted_data := encrpp(c, data)
	decrypted_data := deccrp(c, encrypted_data)
	if data != string(decrypted_data) {
		t.Error(data, string(decrypted_data))
		t.Errorf("decrypt failed:\ngot : % 02x\nwant: % 02x", decrypted_data, data)
	}
}
